#include <OneButton.h>
#include <SPI.h>
#include <TFT_eSPI.h>
#include <HardwareSerial.h>

HardwareSerial SerialPort(2);  //if using UART2

#define RT0 10000   // Î©
#define B 3950      // K

#define VCC 5
#define R 10000

OneButton buttonUp(22, true);
OneButton buttonDown(21, true);
OneButton buttonPower(0, true);


int counter = 0;

TFT_eSPI tft = TFT_eSPI(240, 320);

const int BUFFER_SIZE = 12;
const int BUFFER_SIZE_UP = 13;

byte buf[BUFFER_SIZE];
byte buf_up[BUFFER_SIZE_UP] = {13, 1, 245, 86, 41, 74, 40, 202, 4, 20, 1, 50, 14}; // sample packet generated by the web calculator

int batteryLevel = 0;
int previousBatteryLevel = -1;

int power = 0;
int engineTemp = 0; 
int controllerTemp = 0;
int previousEngineTemp = -1; 
int previousControllerTemp = -1; 
int speed = 0;

int currentGear = 0;
int previousGearDisplay = -1;
int previousGearWalk = 0;
int maxGear = 5;
int initialMaxSpeedB2 = 0;
int initialMaxSpeedB4 = 0;

int gearColor = 0;

bool state = false;
bool testing = false;

long lastTime = millis();

float RT, VR, ln, tx, t0, VRT;
const int samples = 10;

void setup() {
  //Setup serial connection
  // t0 = 25 + 273.15;
  tft.init();
  tft.setRotation(6);
  initialRender();
  initialMaxSpeedB2 = buf_up[2] & 248;
  initialMaxSpeedB4 = buf_up[4] & 32;

  buttonUp.attachClick(increaseGear);
  buttonUp.attachLongPressStart(toggleLimit);
  buttonDown.attachClick(decreaseGear);
  buttonDown.attachLongPressStart(walkMode);
  buttonDown.attachLongPressStop(stopWalkMode);
  buttonPower.attachLongPressStart(toggleTesting);

  Serial.begin(9600);
  SerialPort.begin(9600, SERIAL_8N1, 16, 17);
  digitalWrite(5, HIGH);
}

void loop() {
  long time = millis();
  if (SerialPort.available() >= BUFFER_SIZE) { // check if there are enough available bytes to read
    SerialPort.readBytes(buf, BUFFER_SIZE); // read bytes to the buf array
  }
  shiftArray();
  buf_up[1] = currentGear;
  buf_up[5] = calculateCRC(buf_up);
  SerialPort.write(buf_up, BUFFER_SIZE_UP);
  buttonUp.tick();
  buttonDown.tick();
  buttonPower.tick();
  processPacket(buf);
  getControllerTemperature();
  if (testing) {
    handleTestingDisplay();
  }
  else {
    handleDisplay(false);
    if (millis() - time < 30) {
      delay(30 - (millis() - time));
    }
    if (counter == 1200) {
      clearDisplay();
      counter = -1;
    }
    counter++;
  }
}

void increaseGear() {
  if (currentGear < maxGear) {
    currentGear++;
  }
} 
void decreaseGear(){       
  if (currentGear > 0) {
    currentGear--;
  }
}
void walkMode() {
  previousGearWalk = currentGear;
  currentGear = 6;
}
void stopWalkMode() {
  currentGear = previousGearWalk;
}
void toggleLimit() {
  if (state) {
    buf_up[2] = buf_up[2] & 7;
    buf_up[4] = buf_up[4] & 223;
    buf_up[2] = buf_up[2] | initialMaxSpeedB2;
    buf_up[4] = buf_up[4] | initialMaxSpeedB4;
    gearColor = 0;
    updateGear(true, gearColor);
    maxGear = 5;
    state = false;
  }
  else {
    buf_up[2] = buf_up[2] & 7;
    buf_up[4] = buf_up[4] & 223;
    buf_up[2] = buf_up[2] | ((15 & 31) * 8 );
    buf_up[4] = buf_up[4] | (15 & 32);
    gearColor = 1;
    updateGear(true, gearColor);
    if (currentGear > 2) {
      currentGear = 2;
    }
    maxGear = 2;
    state = true;
  }
}

int calculateCRC(byte buf_up[]) {
  int crc = 0;
  for (int i = 0; i < BUFFER_SIZE_UP; i++) {
    if (i != 5) {
      crc ^= buf_up[i];
    }
  }
  crc ^= 3;
  return crc;
}

void processPacket(byte buf[]) {
  if (buf[3] + buf[4] <= 0) {
    speed = 0;
  }
  else {
    speed = round(60000 / (buf[3] * 256 + buf[4]) * 0.1885 * 0.66 * 10);
  }

  if (buf[1] > 16) {
    batteryLevel = 16;
  }
  else {
    batteryLevel = buf[1];
  }

  power = buf[8] * 13;
  engineTemp = uint8_t(buf[9]) + 15;
}

void handleDisplay(bool force) {
  tft.setTextFont(0);
  updateBattery(batteryLevel / 4, force);
  updateEngineTemp(force);
  updateControllerTemp();
  updatePower();
  updateTime();
  updateGear(force, gearColor);
  updateSpeed();
}

void handleTestingDisplay() {
  tft.fillScreen(TFT_BLACK);
  tft.setTextFont(0);
  tft.setTextSize(2);
  tft.setCursor(0, 60);
  tft.setTextColor(TFT_WHITE, 0);
  for (int i = 0; i < 12; i++) {
    tft.print("B");
    tft.print(i);
    tft.print(": ");
    tft.println(buf[i]);
  }
  delay(200);
}

void initialRender() {
  tft.fillScreen(TFT_BLACK);
  // Draw battery
  tft.drawRoundRect(10, 16, 80, 24, 4, TFT_GREEN);
  tft.fillRect(90, 23, 3, 10, TFT_GREEN);
  tft.fillRoundRect(92, 23, 3, 10, 2, TFT_GREEN);

  tft.drawFastHLine(0, 54, 240, TFT_WHITE);
  tft.drawFastHLine(0, 248, 240, TFT_WHITE);
}

void updateBattery(int bars, bool force) {
  if (previousBatteryLevel != batteryLevel || force) {
    tft.fillRect(10, 16, 100, 25, TFT_BLACK);
    tft.drawRoundRect(10, 16, 80, 24, 4, TFT_GREEN);
    tft.fillRect(90, 23, 3, 10, TFT_GREEN);
    tft.fillRoundRect(92, 23, 3, 10, 2, TFT_GREEN);
    for (int i = 0; i < bars; i++) {
      int x = i * 19 + 13;
      tft.fillRoundRect(x, 19, 17, 18, 2, TFT_GREEN);
    }
    previousBatteryLevel = batteryLevel;
  }
}

void updateGear(bool force, int color) {
  if (previousGearDisplay != currentGear || force) {
    tft.setTextFont(7);
    tft.setTextSize(1);
    if (color == 1) {
      tft.setTextColor(TFT_GREEN, 0);
    }
    else {
      tft.setTextColor(TFT_YELLOW, 0);
    }
    tft.setCursor(108, 180);
    tft.print(currentGear);
    previousGearDisplay = currentGear;
  }
}

void updateEngineTemp(bool force) {
  if (previousEngineTemp != engineTemp || force) {
    tft.setTextSize(2);
    tft.setCursor(16, 265);
    tft.setTextColor(TFT_WHITE, 0);
    tft.print("MTP:");
    tft.setTextColor(0x007CFF, 0);
    if (engineTemp < 10) {
      tft.print("  ");
      tft.print(engineTemp);
    }
    else if (engineTemp < 100) {
      tft.print(" ");
      tft.print(engineTemp);
    }
    else {
      tft.print(engineTemp);
    }
    tft.print("C");
    previousEngineTemp = engineTemp;
  }
}

void clearDisplay() {
  initialRender();
  handleDisplay(true);
}

void updateControllerTemp() {
  tft.setTextSize(2);
  tft.setCursor(140, 265);
  tft.setTextColor(TFT_WHITE, 0);
  tft.print("CTP:");
  tft.setTextColor(0x007CFF, 0);
  tft.print(controllerTemp);
  tft.print("C");
  previousControllerTemp = controllerTemp;
}

void updatePower() {
  tft.setTextSize(2);
  tft.setCursor(16, 290);
  tft.setTextColor(TFT_WHITE, 0);
  tft.print("MP:");
  tft.setTextColor(0x007CFF, 0);
  if (power < 10) {
    tft.print("   ");
  }
  else if (power < 100) {
    tft.print("  ");
  }
  else if (power < 1000) {
    tft.print(" ");
  }
  tft.print(power);
  tft.println("W");
}

void updateSpeed() {
  tft.setTextColor(TFT_WHITE, 0);
  tft.setCursor(40, 86);
  tft.setTextFont(8);
  tft.setTextSize(1);
  int a = 0;
  int b = 0;
  if (speed > 10) {
    a = speed / 10;
    b = speed - (a * 10);
  }
  if (a < 10) {
    tft.print(0);
    tft.print(a);
  }
  else {
    tft.print(a);
  }
  tft.setTextFont(6);
  tft.setTextSize(1);
  tft.setCursor(145, 124);
  tft.print(".");
  tft.print(b);
}

void updateTime() {
  tft.setTextSize(2);
  tft.setCursor(118, 290);
  tft.setTextColor(TFT_WHITE, 0);
  tft.print("TIME:");
  tft.setTextColor(0x007CFF, 0);
  long time = millis() - lastTime;
  if (time < 100) {
    tft.print(time);
    tft.println("ms");
  }
  lastTime = millis();
}

void getControllerTemperature() {
  float sum = 0;
  for (int i=0; i < samples; i++) {
    VRT = (5.00 / 1023.00) * analogRead(27);
    VR = VCC - VRT;
    RT = VRT / (VR / R);               //Resistance of RT
  
    ln = log(RT / RT0);
    tx = (1 / ((ln / B) + (1 / t0))); //Temperature from thermistor
  
    tx = tx - 273.15;                 //Conversion to Celsius
    sum += TX;
  }
  controllerTemp = sum / samples;
}

void shiftArray() {
  int crc = calculateXOR();
  if (buf[0] != 65) {
    byte newBuf[BUFFER_SIZE];
    int shift = 0;
    for (int i = 1; i < BUFFER_SIZE; i++) {
        if (buf[i] == 65) {
            shift = i;
        }
    }
    shift = BUFFER_SIZE - shift;
    for(int i = 0; i < BUFFER_SIZE; i++){
      if(i < shift){
          newBuf[i] = buf[BUFFER_SIZE + i - shift];
      }
      else{
          newBuf[i] = buf[i - shift];
      }
    }
    // if (buf[0] != 65) {
    //   memcpy(newBuf, buf, BUFFER_SIZE);
    //   shiftArray();
    // }
    // else {
      memcpy(buf, newBuf, BUFFER_SIZE);
    // }
  }
}

void toggleTesting() {
  testing = !testing;
}

int calculateXOR() {
  int crc = 0;
  for (int i = 0; i < BUFFER_SIZE; i++) {
    if (i != 6) {
      crc ^= buf[i];
    }
  }
  return crc;
}

